#!/bin/sh
# mt-fetch â€” tiny MT fetch helper (POSIX, source-safe)
# commands: new-run / pack-evidence / normalize

say() { printf '%s\n' "$*"; }

# If sourced, "return" works; if executed, it doesn't.
mt_exit() { code="${1:-0}"; return "$code" 2>/dev/null || exit "$code"; }

usage() {
  cat <<'USAGE'
mt-fetch â€” MT fetch helper (POSIX)

usage:
  mt-fetch help
  mt-fetch new-run --source <id> [--run-id <id>] [--mode manual|http|api] [--tag <t>]... [--inuid <id>] [--repo <path>]
  mt-fetch pack-evidence --run-id <id> [--source <id>] [--repo <path>]
  mt-fetch normalize --run-id <id> [--source <id>] [--repo <path>] [--include-names]

notes:
  - works from any cwd
  - default repo root inferred from this script location (â€¦/tooling/bin/mt-fetch â†’ repo root)
  - prefers mt_fetcher python modules; falls back to stdlib-only python when import fails
  - does NOT run apt; missing tools may print OS install suggestions (harmless)
USAGE
}

# infer repo root from script path (POSIX)
self="$0"
case "$self" in
  /*) self_path="$self" ;;
  *) self_path="$(pwd)/$self" ;;
esac
script_dir="$(CDPATH= cd -- "$(dirname -- "$self_path")" 2>/dev/null && pwd)"
repo_default="$(CDPATH= cd -- "$script_dir/../.." 2>/dev/null && pwd)"
repo="$repo_default"

cmd="${1:-help}"
shift 2>/dev/null || true

run_id=""
source_id=""
mode="manual"
inuid=""
tags_csv=""
include_names=""

while [ $# -gt 0 ]; do
  case "$1" in
    --repo) repo="$2"; shift 2 ;;
    --run-id) run_id="$2"; shift 2 ;;
    --source) source_id="$2"; shift 2 ;;
    --mode) mode="$2"; shift 2 ;;
    --inuid) inuid="$2"; shift 2 ;;
    --tag) tags_csv="${tags_csv}${tags_csv:+,}$2"; shift 2 ;;
    --include-names) include_names="1"; shift 1 ;;
    -h|--help) cmd="help"; shift 1 ;;
    *) say "ðŸ”´ ðŸŸ¦ b # ERROR: unknown arg: $1"; say ""; usage; mt_exit 0 ;;
  esac
done

if [ ! -d "$repo/.git" ]; then
  say "ðŸ”´ ðŸŸ¦ b # ERROR: repo missing .git: $repo"
  say "ðŸ”¹ lb # NOTE: pass --repo <path>"
  mt_exit 0
fi

pyroot="$repo/library/py"

var_root="$repo/var/mt"
raw_base="$var_root/fetch/raw"
evid_base="$var_root/evidence"
norm_base="$var_root/normalize"
sum_base="$var_root/summaries"

mkdir -p "$raw_base" "$evid_base" "$norm_base" "$sum_base" >/dev/null 2>&1 || true

case "$cmd" in
  help|"")
    usage
    mt_exit 0
    ;;
  new-run)
    [ -n "$source_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --source required"; usage; mt_exit 0; }
    [ -n "$run_id" ] || run_id="run-$(date +%Y%m%d-%H%M%S)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"
    norm_dir="$norm_base/$run_id"
    sum_dir="$sum_base/$run_id"

    inbox_dir="$raw_dir/inbox"
    notes_md="$raw_dir/notes.md"
    ctx_json="$raw_dir/context.json"

    say "ðŸŸ¦ b # NEW-RUN: run_id=$run_id source=$source_id mode=$mode"
    mkdir -p "$raw_dir" "$evid_dir" "$norm_dir" "$sum_dir" "$inbox_dir" >/dev/null 2>&1 || true

    if [ ! -f "$notes_md" ]; then
      printf '%s\n' "# notes (run_id=$run_id)" >"$notes_md" 2>/dev/null || true
    fi

    if [ ! -f "$ctx_json" ]; then
      if command -v python3 >/dev/null 2>&1; then
        env RUN_ID="$run_id" SOURCE_ID="$source_id" TAGS="$tags_csv" INUID="$inuid" \
          python3 - <<'PY' >"$ctx_json" 2>/dev/null
import json, os, datetime
run_id=os.environ.get("RUN_ID","")
source_id=os.environ.get("SOURCE_ID","")
tags=os.environ.get("TAGS","")
tags_list=[t for t in tags.split(",") if t] if tags else []
inuid=os.environ.get("INUID","")
now=datetime.datetime.utcnow().replace(microsecond=0).isoformat()+"Z"
print(json.dumps({
  "run_id": run_id,
  "source_id": source_id,
  "created_utc": now,
  "retrieved_utc": now,
  "tags": tags_list,
  "inuid": inuid
}, indent=2, sort_keys=True))
PY
      else
        # stdlib fallback unavailable; write minimal JSON-ish (still valid JSON)
        cat >"$ctx_json" <<EOF
{"run_id":"$run_id","source_id":"$source_id","created_utc":"","retrieved_utc":"","tags":[],"inuid":"$inuid"}
EOF
      fi
    fi

    say "ðŸŸ¦ b # PATHS"
    say "raw_dir: $raw_dir"
    say "inbox:   $inbox_dir"
    say "ctx:     $ctx_json"
    mt_exit 0
    ;;
  pack-evidence)
    [ -n "$run_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --run-id required"; usage; mt_exit 0; }
    [ -n "$source_id" ] || source_id="(unset)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"

    if [ ! -d "$raw_dir" ]; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: raw_dir missing: $raw_dir"
      mt_exit 0
    fi
    mkdir -p "$evid_dir" >/dev/null 2>&1 || true

    say "ðŸŸ¦ b # PACK-EVIDENCE: run_id=$run_id source=$source_id"
    say "ðŸŸ¦ b # raw_dir=$raw_dir"
    say "ðŸŸ¦ b # evid_dir=$evid_dir"

    if ! command -v python3 >/dev/null 2>&1; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: python3 required for hashing"
      mt_exit 0
    fi

    # prefer mt_fetcher.evidence
    if PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" python3 - <<'PY' >/dev/null 2>&1
from mt_fetcher.evidence import pack
PY
    then
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" EVID_DIR="$evid_dir" \
        PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" \
        python3 - <<'PY'
from pathlib import Path
from mt_fetcher.evidence import pack
import os
raw_dir=Path(os.environ["RAW_DIR"])
evid_dir=Path(os.environ["EVID_DIR"])
run_id=os.environ["RUN_ID"]
source_id=os.environ["SOURCE_ID"]
files=[p for p in raw_dir.rglob("*") if p.is_file()]
ep=pack(run_root=evid_dir, files=files, meta={"run_id":run_id,"source_id":source_id,"mode":"manual","note":"mt-fetch pack-evidence"})
print("ðŸŸ¢ ðŸŸ¦ b # OK: mt_fetcher.evidence.pack")
print("manifest:", ep.manifest_path)
print("provenance:", ep.provenance_path)
print("files:", len(ep.files))
PY
    else
      # stdlib fallback
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" EVID_DIR="$evid_dir" \
        python3 - <<'PY'
import hashlib, json, os
from pathlib import Path
run_id=os.environ["RUN_ID"]
source_id=os.environ["SOURCE_ID"]
raw_dir=Path(os.environ["RAW_DIR"])
evid_dir=Path(os.environ["EVID_DIR"])
evid_dir.mkdir(parents=True, exist_ok=True)
def sha256_file(p: Path) -> str:
  h=hashlib.sha256()
  with p.open("rb") as f:
    for chunk in iter(lambda: f.read(1024*1024), b""):
      h.update(chunk)
  return h.hexdigest()
files=[]
for p in raw_dir.rglob("*"):
  if p.is_file():
    files.append({"path": str(p), "sha256": sha256_file(p), "size_bytes": p.stat().st_size})
(manifest_path:=evid_dir/"manifest.json").write_text(json.dumps({"files": files}, indent=2, sort_keys=True), encoding="utf-8")
(prov_path:=evid_dir/"provenance.json").write_text(json.dumps({"meta":{"run_id":run_id,"source_id":source_id,"mode":"manual","note":"fallback pack-evidence (stdlib)"}}, indent=2, sort_keys=True), encoding="utf-8")
print("ðŸŸ¡ ðŸŸ¦ b # NOTE: used stdlib fallback")
print("manifest:", manifest_path)
print("provenance:", prov_path)
print("files:", len(files))
PY
    fi
    mt_exit 0
    ;;
  normalize)
    [ -n "$run_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --run-id required"; usage; mt_exit 0; }
    [ -n "$source_id" ] || source_id="(unset)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"
    norm_dir="$norm_base/$run_id"
    items_out="$norm_dir/items.jsonl"
    manifest="$evid_dir/manifest.json"

    if [ ! -f "$manifest" ]; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: missing manifest: $manifest"
      say "ðŸ”¹ lb # NOTE: run pack-evidence first"
      mt_exit 0
    fi

    mkdir -p "$norm_dir" >/dev/null 2>&1 || true

    say "ðŸŸ¦ b # NORMALIZE: run_id=$run_id source=$source_id"
    say "ðŸŸ¦ b # out=$items_out"

    if ! command -v python3 >/dev/null 2>&1; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: python3 required for normalize"
      mt_exit 0
    fi

    if PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" python3 - <<'PY' >/dev/null 2>&1
from mt_fetcher.normalize import normalize_run
PY
    then
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" MANIFEST="$manifest" NORM_DIR="$norm_dir" INCLUDE_NAMES="$include_names" \
        PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" \
        python3 - <<'PY'
from pathlib import Path
from mt_fetcher.normalize import normalize_run
import os
res = normalize_run(
  run_id=os.environ["RUN_ID"],
  source_id=os.environ["SOURCE_ID"],
  raw_dir=Path(os.environ["RAW_DIR"]),
  evidence_manifest=Path(os.environ["MANIFEST"]),
  out_dir=Path(os.environ["NORM_DIR"]),
  include_names=(os.environ.get("INCLUDE_NAMES")=="1"),
)
print("ðŸŸ¢ ðŸŸ¦ b # OK: mt_fetcher.normalize")
print("items:", res.items_path)
print("count:", res.count)
PY
    else
      # stdlib fallback
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" MANIFEST="$manifest" NORM_DIR="$norm_dir" INCLUDE_NAMES="$include_names" \
        python3 - <<'PY'
import json, mimetypes, os
from pathlib import Path
run_id=os.environ["RUN_ID"]
source_id=os.environ["SOURCE_ID"]
raw_dir=Path(os.environ["RAW_DIR"])
manifest=Path(os.environ["MANIFEST"])
norm_dir=Path(os.environ["NORM_DIR"])
include_names=(os.environ.get("INCLUDE_NAMES")=="1")
ctx={}
ctx_path=raw_dir/"context.json"
if ctx_path.is_file():
  try: ctx=json.loads(ctx_path.read_text(encoding="utf-8"))
  except Exception: ctx={}
tags = ctx.get("tags") if isinstance(ctx.get("tags"), list) else []
retrieved = ctx.get("retrieved_utc") or ctx.get("created_utc") or ""
m=json.loads(manifest.read_text(encoding="utf-8"))
files=m.get("files", [])
out=norm_dir/"items.jsonl"
count=0
with out.open("w", encoding="utf-8") as f:
  for ent in files:
    sha=ent.get("sha256","")
    size=ent.get("size_bytes",0)
    raw_path=ent.get("path","")
    ctype=mimetypes.guess_type(raw_path)[0] or "application/octet-stream"
    title=f"artifact:{sha[:12]}" if sha else "artifact:unknown"
    if include_names and raw_path:
      title=Path(raw_path).name
    f.write(json.dumps({
      "schema":"mt.normalize.item.v1",
      "run_id":run_id,
      "source_id":source_id,
      "retrieved_utc":retrieved,
      "title":title,
      "url":ctx.get("url",""),
      "content_type":ctype,
      "raw_evidence_sha256":sha,
      "size_bytes":size,
      "tags":tags
    }, sort_keys=True) + "\n")
    count+=1
(norm_dir/"normalize.meta.json").write_text(json.dumps({"meta":{"run_id":run_id,"source_id":source_id,"retrieved_utc":retrieved,"tags":tags},"count":count}, indent=2, sort_keys=True), encoding="utf-8")
print("ðŸŸ¡ ðŸŸ¦ b # NOTE: used stdlib fallback normalize")
print("items:", out)
print("count:", count)
PY
    fi

    if command -v jq >/dev/null 2>&1; then
      say "ðŸŸ¦ b # jq: preview (first 10 items)"
      jq -S -s '.[0:10]' "$items_out" 2>/dev/null || true
    else
      say "ðŸŸ¡ ðŸŸ¦ b # NOTE: jq not found; skipping preview"
    fi

    mt_exit 0
    ;;
  *)
    say "ðŸ”´ ðŸŸ¦ b # ERROR: unknown command: $cmd"
    say ""
    usage
    mt_exit 0
    ;;
esac
