#!/bin/sh
# mt-fetch â€” tiny MT fetch helper (POSIX, source-safe)
# commands: new-run / pack-evidence / normalize
# privacy: hash-first; no raw paths; filenames only with explicit context opt-in

say() { printf '%s\n' "$*"; }
mt_exit() { code="${1:-0}"; return "$code" 2>/dev/null || exit "$code"; }

usage() {
  cat <<'USAGE'
mt-fetch â€” MT fetch helper (POSIX)

usage:
  mt-fetch help
  mt-fetch new-run --source <id> [--run-id <id>] [--mode manual|http|api] [--tag <t>]... [--inuid <id>] [--repo <path>]
  mt-fetch pack-evidence --run-id <id> [--source <id>] [--repo <path>]
  mt-fetch normalize --run-id <id> [--source <id>] [--repo <path>] [--include-names]

notes:
  - works from any cwd
  - default repo inferred from script location (â€¦/tooling/bin/mt-fetch â†’ repo root)
  - source-safe: never hard-exits your shell when sourced
  - privacy gate: --include-names only works if context.json allows it + has a reason
  - normalize writes var/mt/latest/mt-fetch.normalize.status.v1.json for UIBoss
USAGE
}

# infer repo root from script path (POSIX)
self="$0"
case "$self" in
  /*) self_path="$self" ;;
  *) self_path="$(pwd)/$self" ;;
esac
script_dir="$(CDPATH= cd -- "$(dirname -- "$self_path")" 2>/dev/null && pwd)"
repo_default="$(CDPATH= cd -- "$script_dir/../.." 2>/dev/null && pwd)"
repo="$repo_default"

cmd="${1:-help}"
shift 2>/dev/null || true

run_id=""
source_id=""
mode="manual"
inuid=""
tags_csv=""
include_names=""

while [ $# -gt 0 ]; do
  case "$1" in
    --repo) repo="$2"; shift 2 ;;
    --run-id) run_id="$2"; shift 2 ;;
    --source) source_id="$2"; shift 2 ;;
    --mode) mode="$2"; shift 2 ;;
    --inuid) inuid="$2"; shift 2 ;;
    --tag) tags_csv="${tags_csv}${tags_csv:+,}$2"; shift 2 ;;
    --include-names) include_names="1"; shift 1 ;;
    -h|--help) cmd="help"; shift 1 ;;
    *) say "ðŸ”´ ðŸŸ¦ b # ERROR: unknown arg: $1"; say ""; usage; mt_exit 0 ;;
  esac
done

if [ ! -d "$repo/.git" ]; then
  say "ðŸ”´ ðŸŸ¦ b # ERROR: repo missing .git: $repo"
  say "ðŸ”¹ lb # NOTE: pass --repo <path>"
  mt_exit 0
fi

pyroot="$repo/library/py"

var_root="$repo/var/mt"
raw_base="$var_root/fetch/raw"
evid_base="$var_root/evidence"
norm_base="$var_root/normalize"
sum_base="$var_root/summaries"
latest_dir="$var_root/latest"

mkdir -p "$raw_base" "$evid_base" "$norm_base" "$sum_base" "$latest_dir" >/dev/null 2>&1 || true

case "$cmd" in
  help|"")
    usage
    mt_exit 0
    ;;
  new-run)
    [ -n "$source_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --source required"; usage; mt_exit 0; }
    [ -n "$run_id" ] || run_id="run-$(date +%Y%m%d-%H%M%S)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"
    norm_dir="$norm_base/$run_id"
    sum_dir="$sum_base/$run_id"

    inbox_dir="$raw_dir/inbox"
    notes_md="$raw_dir/notes.md"
    ctx_json="$raw_dir/context.json"

    say "ðŸŸ¦ b # NEW-RUN: run_id=$run_id source=$source_id mode=$mode"
    mkdir -p "$raw_dir" "$evid_dir" "$norm_dir" "$sum_dir" "$inbox_dir" >/dev/null 2>&1 || true

    if [ ! -f "$notes_md" ]; then
      printf '%s\n' "# notes (run_id=$run_id)" >"$notes_md" 2>/dev/null || true
    fi

    if [ ! -f "$ctx_json" ]; then
      if command -v python3 >/dev/null 2>&1; then
        env RUN_ID="$run_id" SOURCE_ID="$source_id" TAGS="$tags_csv" INUID="$inuid" \
          python3 - <<'PY' >"$ctx_json" 2>/dev/null
import json, os, datetime
run_id=os.environ.get("RUN_ID","")
source_id=os.environ.get("SOURCE_ID","")
tags=os.environ.get("TAGS","")
tags_list=[t for t in tags.split(",") if t] if tags else []
inuid=os.environ.get("INUID","")
now=datetime.datetime.utcnow().replace(microsecond=0).isoformat()+"Z"
print(json.dumps({
  "run_id": run_id,
  "source_id": source_id,
  "created_utc": now,
  "retrieved_utc": now,
  "tags": tags_list,
  "inuid": inuid,
  "privacy": {
    "allow_names": False,
    "allow_names_reason": ""
  }
}, indent=2, sort_keys=True))
PY
      else
        cat >"$ctx_json" <<EOF
{"run_id":"$run_id","source_id":"$source_id","created_utc":"","retrieved_utc":"","tags":[],"inuid":"$inuid","privacy":{"allow_names":false,"allow_names_reason":""}}
EOF
      fi
    fi

    say "ðŸŸ¦ b # PATHS"
    say "raw_dir: $raw_dir"
    say "inbox:   $inbox_dir"
    say "ctx:     $ctx_json"
    mt_exit 0
    ;;
  pack-evidence)
    [ -n "$run_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --run-id required"; usage; mt_exit 0; }
    [ -n "$source_id" ] || source_id="(unset)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"

    if [ ! -d "$raw_dir" ]; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: raw_dir missing: $raw_dir"
      mt_exit 0
    fi
    mkdir -p "$evid_dir" >/dev/null 2>&1 || true

    say "ðŸŸ¦ b # PACK-EVIDENCE: run_id=$run_id source=$source_id"
    say "ðŸŸ¦ b # raw_dir=$raw_dir"
    say "ðŸŸ¦ b # evid_dir=$evid_dir"

    if ! command -v python3 >/dev/null 2>&1; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: python3 required for hashing"
      mt_exit 0
    fi

    if PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" python3 - <<'PY' >/dev/null 2>&1
from mt_fetcher.evidence import pack
PY
    then
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" EVID_DIR="$evid_dir" \
        PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" \
        python3 - <<'PY'
from pathlib import Path
from mt_fetcher.evidence import pack
import os
raw_dir=Path(os.environ["RAW_DIR"])
evid_dir=Path(os.environ["EVID_DIR"])
run_id=os.environ["RUN_ID"]
source_id=os.environ["SOURCE_ID"]
files=[p for p in raw_dir.rglob("*") if p.is_file()]
ep=pack(run_root=evid_dir, files=files, meta={"run_id":run_id,"source_id":source_id,"mode":"manual","note":"mt-fetch pack-evidence"})
print("ðŸŸ¢ ðŸŸ¦ b # OK: mt_fetcher.evidence.pack")
print("manifest:", ep.manifest_path)
print("provenance:", ep.provenance_path)
print("files:", len(ep.files))
PY
    else
      say "ðŸŸ¡ ðŸŸ¦ b # NOTE: mt_fetcher.evidence missing; keep using your existing pack path"
    fi
    mt_exit 0
    ;;
  normalize)
    [ -n "$run_id" ] || { say "ðŸ”´ ðŸŸ¦ b # ERROR: --run-id required"; usage; mt_exit 0; }
    [ -n "$source_id" ] || source_id="(unset)"

    raw_dir="$raw_base/$run_id"
    evid_dir="$evid_base/$run_id"
    norm_dir="$norm_base/$run_id"
    manifest="$evid_dir/manifest.json"
    items_out="$norm_dir/items.jsonl"
    meta_out="$norm_dir/normalize.meta.json"
    status_json="$latest_dir/mt-fetch.normalize.status.v1.json"

    if [ ! -f "$manifest" ]; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: missing manifest: $manifest"
      say "ðŸ”¹ lb # NOTE: run pack-evidence first"
      mt_exit 0
    fi

    mkdir -p "$norm_dir" >/dev/null 2>&1 || true

    # privacy gate for include_names
    if [ "$include_names" = "1" ]; then
      allow="0"
      reason_ok="0"
      ctx="$raw_dir/context.json"
      if command -v python3 >/dev/null 2>&1 && [ -f "$ctx" ]; then
        allow="$(python3 - <<PY 2>/dev/null
import json
from pathlib import Path
p=Path("$ctx")
try:
  d=json.loads(p.read_text(encoding="utf-8"))
  priv=d.get("privacy") or {}
  print("1" if priv.get("allow_names") is True else "0")
except Exception:
  print("0")
PY
)"
        reason_ok="$(python3 - <<PY 2>/dev/null
import json
from pathlib import Path
p=Path("$ctx")
try:
  d=json.loads(p.read_text(encoding="utf-8"))
  priv=d.get("privacy") or {}
  r=str(priv.get("allow_names_reason") or "").strip()
  print("1" if len(r) > 0 else "0")
except Exception:
  print("0")
PY
)"
      fi

      if [ "$allow" != "1" ] || [ "$reason_ok" != "1" ]; then
        say "ðŸ”´ ðŸŸ¦ b # ERROR: --include-names denied by privacy contract"
        say "ðŸ”¹ lb # NOTE: set context.json privacy.allow_names=true and privacy.allow_names_reason non-empty (then rerun)"
        say "ðŸŸ¡ ðŸŸ¦ b # SAFE-DEGRADE: proceeding WITHOUT names"
        include_names=""
      fi
    fi

    say "ðŸŸ¦ b # NORMALIZE: run_id=$run_id source=$source_id"
    say "ðŸŸ¦ b # out=$items_out"

    if ! command -v python3 >/dev/null 2>&1; then
      say "ðŸ”´ ðŸŸ¦ b # ERROR: python3 required for normalize"
      mt_exit 0
    fi

    if PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" python3 - <<'PY' >/dev/null 2>&1
from mt_fetcher.normalize import normalize_run
PY
    then
      env RUN_ID="$run_id" SOURCE_ID="$source_id" RAW_DIR="$raw_dir" MANIFEST="$manifest" NORM_DIR="$norm_dir" INCLUDE_NAMES="$include_names" \
        PYTHONPATH="$pyroot${PYTHONPATH:+:$PYTHONPATH}" \
        python3 - <<'PY'
from pathlib import Path
from mt_fetcher.normalize import normalize_run
import os
res = normalize_run(
  run_id=os.environ["RUN_ID"],
  source_id=os.environ["SOURCE_ID"],
  raw_dir=Path(os.environ["RAW_DIR"]),
  evidence_manifest=Path(os.environ["MANIFEST"]),
  out_dir=Path(os.environ["NORM_DIR"]),
  include_names=(os.environ.get("INCLUDE_NAMES")=="1"),
)
print("ðŸŸ¢ ðŸŸ¦ b # OK: mt_fetcher.normalize")
print("items:", res.items_path)
print("count:", res.count)
PY
    else
      say "ðŸ”´ ðŸŸ¦ b # ERROR: mt_fetcher.normalize not importable (PYTHONPATH issue)"
      mt_exit 0
    fi

    # write UIBoss status JSON (no raw paths)
    python3 - <<PY >/dev/null 2>&1
import json, subprocess, datetime
from pathlib import Path

repo=Path("$repo")
norm_dir=Path("$norm_dir")
meta_path=norm_dir/"normalize.meta.json"

count=0
if meta_path.is_file():
  try:
    count=int(json.loads(meta_path.read_text(encoding="utf-8")).get("count",0))
  except Exception:
    count=0

def sh(cmd):
  try:
    return subprocess.check_output(cmd, cwd=str(repo), text=True).strip()
  except Exception:
    return ""

sha=sh(["git","rev-parse","HEAD"])
branch=sh(["git","rev-parse","--abbrev-ref","HEAD"])
now=datetime.datetime.utcnow().replace(microsecond=0).isoformat()+"Z"

status={
  "schema":"mt.fetch.normalize.status.v1",
  "updated_utc": now,
  "repo": {"path": str(repo), "git_sha": sha, "git_branch": branch},
  "run": {"run_id": "$run_id", "source_id": "$source_id"},
  "counts": {"items": count},
  "outputs": {
    "items_jsonl": "var/mt/normalize/$run_id/items.jsonl",
    "meta_json": "var/mt/normalize/$run_id/normalize.meta.json"
  }
}

out=Path("$status_json")
out.parent.mkdir(parents=True, exist_ok=True)
out.write_text(json.dumps(status, indent=2, sort_keys=True), encoding="utf-8")
PY

    if command -v jq >/dev/null 2>&1; then
      say "ðŸŸ¦ b # jq: latest status"
      jq -S . "$status_json" 2>/dev/null || true
      say "ðŸŸ¦ b # jq: preview (first 10 items)"
      jq -S -s '.[0:10]' "$items_out" 2>/dev/null || true
    else
      say "ðŸŸ¡ ðŸŸ¦ b # NOTE: jq not found; skipping pretty output"
    fi

    mt_exit 0
    ;;
  *)
    say "ðŸ”´ ðŸŸ¦ b # ERROR: unknown command: $cmd"
    say ""
    usage
    mt_exit 0
    ;;
esac
